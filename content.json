{"meta":{"title":"JoyTan's Blog","subtitle":"做自己，不将就","description":null,"author":"JoyTan","url":"http://joytan1209.github.io"},"pages":[{"title":"关于","date":"2016-04-15T06:51:55.000Z","updated":"2017-06-05T01:44:17.000Z","comments":true,"path":"about/index.html","permalink":"http://joytan1209.github.io/about/index.html","excerpt":"","text":"关于我90后程序猿一枚，主要从事Android平台的软件开发相关工作。懂点Python、Java web、Html。热爱编程，喜欢学习新技术。 关于博客写一些自己在工作、学习及生活中的感悟。 联系方式 邮箱：joytan1209@163.com QQ：354150263"},{"title":"标签","date":"2017-06-05T02:15:26.000Z","updated":"2017-06-05T01:44:17.000Z","comments":false,"path":"tags/index.html","permalink":"http://joytan1209.github.io/tags/index.html","excerpt":"","text":"#Android #移动开发 #Python #Java #杂谈"}],"posts":[{"title":"2017-开启新的征程","slug":"2017-开启新的征程","date":"2017-02-05T12:52:32.000Z","updated":"2017-06-05T01:44:17.000Z","comments":true,"path":"2017/02/05/2017-开启新的征程/","link":"","permalink":"http://joytan1209.github.io/2017/02/05/2017-开启新的征程/","excerpt":"","text":"2017 开启新的征程时间飞逝，2017年已经开始了一个多月了。刚刚过完春节，在这里做个简短的总结与新年的规划。 我的2016算起来是工作以来最辛苦的一年了吧！离开了老东家，加入了全民创业的大军。二线城市的互联网创业路走起来还是比较艰难的，两个月的时间，第二次创业团队没有组建起来，以失败告终。经过一个月的反思与观察，选择了一个新的创业方向，也如愿以偿找到了一个比较满意的团队，在9月份开始了互联网金融行业的探索之路。","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://joytan1209.github.io/tags/杂谈/"}]},{"title":"浅谈Android App 自动登录实现","slug":"Android APP 自动登录","date":"2016-05-05T06:02:49.000Z","updated":"2017-06-05T01:44:17.000Z","comments":true,"path":"2016/05/05/Android APP 自动登录/","link":"","permalink":"http://joytan1209.github.io/2016/05/05/Android APP 自动登录/","excerpt":"","text":"需求自动登录应该是比较常见的需求了，绝大多数的APP都有这个功能。所谓自动登录，就是登录之后，在下次重启App后用户仍然可以登录，而不需要重新输入用户名和密码。因为每次都要用户输入用户名/密码登录是很麻烦的事情，当然强迫症除外。 实现方式最常见的做法就是，登录成功后，将用户名、密码保存到本地。重拾是判断本地是否有已保存的用户名、密码，如果有则以本地保存的用户名、密码做模拟登录操作。 最常用的保存用户名、密码方法就是使用SharedPreferences了。这里就不介绍SharedPreferences了。 但是，这种方法安全吗？答案是当然不安全了，这种保存方式很容易被窃取。所以在保存用户名、密码时需要做加密处理，而且要用非对称加密方式。对称加密方式在源码外泄时，很容易被方向推算出来。见到过团队就是简单加密后保存的，这种做法存在极大的安全隐患。 还有就是，在登录时有验证码的情况。在这种情况下，就需要重构了，上面的提到的登录方式是不能自动提交验证码的。当然，自动提交验证码就失去了验证码的意义了。此种情况下就需要使用cookie了。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://joytan1209.github.io/tags/Android/"},{"name":"移动开发","slug":"移动开发","permalink":"http://joytan1209.github.io/tags/移动开发/"}]},{"title":"阿里Weex跨平台开发工具开源啦","slug":"阿里Weex跨平台开发工具开源啦","date":"2016-04-22T06:33:53.000Z","updated":"2017-06-05T01:44:17.000Z","comments":true,"path":"2016/04/22/阿里Weex跨平台开发工具开源啦/","link":"","permalink":"http://joytan1209.github.io/2016/04/22/阿里Weex跨平台开发工具开源啦/","excerpt":"","text":"Weex简介 Weex Weex能够完美兼顾性能与动态性，让移动开发者通过简捷的前端语法写出Native级别的性能体验，并支持iOS、安卓、YunOS及Web等多端部署。 阿里巴巴与2016年4月21日在Qcon大会上宣布跨平台开发工具Weex开放内测邀请。可以在官网申请：Weex，又一前端开发者的福音！目前内测邀请只有Android版本，据说，在6月份将全部开源:iOS、Android、H5 解决的痛点Why?为什么要使用呢 Weex主要解决了两大痛点：频繁发版和多端研发，同时解决了前端语言性能差和显示效果受限的问题。 我们只需要在自己的APP中依赖Weex的SDK，就可以用HTML/CSS/JavaScript来开发Native级别的界面。可以部署在服务端，在APP中执行请求。 优势相比最近比较火的开源跨平台移动开放项目React Native，Weex更加轻量，提交更加小巧。当然，他们各自的实现方式有所不同。Weex基于web conponent标准，使得开发更加简洁标准，方便上手。Native组件和API都可以横向扩展，方便根据业务灵活定制。Weex渲染层具备优异的性能表现，能够跨平台实现一致的布局效果和实现。对于前端开发来说，Weex能够实现组件化开发、自动化数据绑定，并拥抱Web标准。 Demo官方的案例： Weex Demo 具体可以在官网下载Weex playground App","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://joytan1209.github.io/tags/杂谈/"}]},{"title":"Androidy启动页广告实现","slug":"Androidy启动页广告实现","date":"2016-04-21T08:50:10.000Z","updated":"2017-06-05T01:44:17.000Z","comments":true,"path":"2016/04/21/Androidy启动页广告实现/","link":"","permalink":"http://joytan1209.github.io/2016/04/21/Androidy启动页广告实现/","excerpt":"","text":"需求启动页展示广告。主要功能：1.在启动的时候显示广告;2.【跳过】功能，倒计时3秒;3.查看广告详情。如图所示： 启动页广告 实现layout布局文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;!-- 广告图片 --&gt; &lt;ImageView android:id=\"@+id/splash_logo\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:visibility=\"visible\" android:scaleType=\"fitXY\"/&gt; &lt;!-- 跳过 --&gt; &lt;LinearLayout android:id=\"@+id/lin_skip\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"right\" android:orientation=\"horizontal\" android:layout_marginTop=\"40dp\" android:padding=\"4dp\" android:layout_marginRight=\"8dp\" android:background=\"@drawable/splash_skip\" android:visibility=\"gone\"&gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:paddingLeft=\"5dp\" android:layout_gravity=\"right\" android:text=\"3\" android:textColor=\"@color/white\" android:textSize=\"16sp\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"right\" android:paddingLeft=\"5dp\" android:paddingRight=\"5dp\" android:text=\"跳过\" android:textColor=\"@color/white\" android:textSize=\"16sp\" /&gt; &lt;/LinearLayout&gt;&lt;/FrameLayout&gt; 【跳过】按钮背景：1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;!-- 填充色 --&gt; &lt;solid android:color=\"#CBCBCB\"/&gt; &lt;!-- 圆角 --&gt; &lt;corners android:radius=\"18dp\"/&gt;&lt;/shape&gt; Activity文件:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class SplashActivity extends BaseActivity implements ISplashActivity &#123; @Bind(R.id.splash_logo) ImageView splashLogo; @Bind(R.id.logo_layout) LinearLayout logoLayout; private Intent intent; @Bind(R.id.textView) TextView textView; @Bind(R.id.lin_skip) LinearLayout linSkip; private int count = 3; private ISplashPresenter splashPresenter; private HttpParams httpParams; private ADBean adBean; /** * 设置root界面 */ @Override public void setRootView() &#123; super.setRootView(); setContentView(R.layout.activity_splansh); ButterKnife.bind(this); &#125; @Override public void initData() &#123; super.initData(); &#125; @Override public void initWidget() &#123; super.initWidget(); init(); &#125; private void init() &#123; logoLayout.setVisibility(View.VISIBLE); splashPresenter = new SplashPresenter(this); httpParams = new HttpParams(); splashPresenter.getSplashAD(httpParams); &#125; @Override public void onGetSplashADSuccess(ADBean adBean) &#123; this.adBean = adBean; if (null != adBean &amp;&amp; null != adBean.getData() &amp;&amp; !\"\".equals(adBean.getData().getImagePath()) &amp;&amp; null != adBean.getData().getImagePath()) &#123; ImageLoader imageLoader = ImageLoader.getInstance(); imageLoader.displayImage(API.FTP_SERVER + adBean.getData().getImagePath(), splashLogo, TrueLoveApp.options); linSkip.setVisibility(View.VISIBLE); handler.sendEmptyMessageDelayed(0, 1000); &#125; else &#123; splashLogo.setImageResource(R.mipmap.ic_splash); splashLogo.setClickable(false); linSkip.setVisibility(View.GONE); handler.sendEmptyMessageDelayed(-1, 1000); &#125; &#125; @OnClick(R.id.splash_logo) public void onSplashLogoClick(View view) &#123; handler.removeMessages(0); startActivtiy(); &#125; @OnClick(R.id.lin_skip) public void OnSkipClick(View view) &#123; handler.removeMessages(0); handler.sendEmptyMessageDelayed(1, 100); &#125; @Override public void onGetSplashADError(String msg) &#123; splashLogo.setImageResource(R.mipmap.ic_splash); splashLogo.postDelayed(new Runnable() &#123; @Override public void run() &#123; intent = new Intent(SplashActivity.this, MainActivity.class); startActivity(intent); finish(); &#125; &#125;, CommonContant.SPLANSH_TIME); &#125; private int getCount() &#123; count--; if (count == 0) &#123; Intent intent = new Intent(this, MainActivity.class); startActivity(intent); finish(); &#125; return count; &#125; private Handler handler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; if (msg.what == 0) &#123; textView.setText(getCount()+\"\"); handler.sendEmptyMessageDelayed(0, 1000); &#125; // 跳过 if (msg.what == 1) &#123; handler.removeMessages(1); Intent intent = new Intent(SplashActivity.this, MainActivity.class); startActivity(intent); finish(); &#125; // 无广告 if (msg.what == -1) &#123; Intent intent = new Intent(SplashActivity.this, MainActivity.class); startActivity(intent); finish(); &#125; &#125;; &#125;; /** * Activity跳转 */ private void startActivtiy() &#123; if (null != adBean) &#123; if (\"1\".equals(adBean.getData().getRelatedContext())) &#123; //shop Intent intent = new Intent(mContext, SellerShopDetailActivity.class); intent.putExtra(\"shopid\", adBean.getData().getRelatedContentId()); mContext.startActivity(intent); &#125; else if (\"2\".equals(adBean.getData().getRelatedContext())) &#123; //product Intent intent = new Intent(mContext, SellerProductDetailActivity.class); intent.putExtra(\"productid\", adBean.getData().getRelatedContentId()); mContext.startActivity(intent); &#125; else &#123; adBean.getData().setAdContent(new String(Base64.decode(adBean.getData().getAdContent(), Base64.DEFAULT))); Intent intent = new Intent(mContext, HomeADDetailActivity.class); intent.putExtra(\"flag\", \"splash\"); intent.putExtra(\"bean\", adBean); mContext.startActivity(intent); &#125; &#125; &#125;&#125; 运行效果启动页： 广告 广告详情： 广告详情","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://joytan1209.github.io/tags/Android/"},{"name":"移动开发","slug":"移动开发","permalink":"http://joytan1209.github.io/tags/移动开发/"}]},{"title":"Android N将逐步实现对VR支持","slug":"Android N将逐步实现对VR支持","date":"2016-04-18T06:07:10.000Z","updated":"2017-06-05T01:44:17.000Z","comments":true,"path":"2016/04/18/Android N将逐步实现对VR支持/","link":"","permalink":"http://joytan1209.github.io/2016/04/18/Android N将逐步实现对VR支持/","excerpt":"","text":"据国外媒体报道，在Android N的开发者预览版中支持VR功能，同时支持Khronos最新Vulkan API。其他还支持全新的3D渲染API（Vulkan）、Emoji Unicode 9、压感屏及面向平板的分屏多任务模式等。 在Android系统中，可以通过以下路径来访问这个炫酷的功能:1Settings（设置） -&gt; Apps（应用） -&gt; Configure apps（应用配置） -&gt; Special Access（特殊访问） -&gt; VR helper services（虚拟现实辅助服务） 然后将显示接入这个API的应用列表，用户可以选择永许或者拒绝。这看起来似乎很快就可以有一个名为VR Listener”或者“VR helper”的应用了。 VR helper services 有关VR的细节暂不清楚，但《华尔街日报》在2月份提到过，Google正赶在推出自家基于智能机的头戴式装之前优化Android，让它能够更好地支持VR设备。 有关VR模式的一个猜想是，其会禁用手机的自锁机制，以避免使用一段时间后突然“黑屏”。此外，Google据说还在打造一款无需智能机或PC的独立装置。 根据报道还说有一个新硬件支持标志，名为“Config Sustained Performance Mode Supported”，Ars Technica的Ron Amadeo觉得它可能是一个特殊的功能，允许持续直接使用手机的CPU和GPU，跟Gear VR能够在兼容的三星手机上运行的方式类似。 我们知道谷歌的虚拟现实雄心远远超过了Cardboard，现在通过这个新版本系统的更新可以得道印证。在2016年第三季度Android N发布之前，谷歌至少在计划另外3个开发商预览版，所以我们可能会继续看到虚拟现实功能的增加。","categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://joytan1209.github.io/tags/杂谈/"},{"name":"Android","slug":"Android","permalink":"http://joytan1209.github.io/tags/Android/"}]},{"title":"Android Studio Gradle","slug":"Gradle","date":"2016-04-09T13:50:04.000Z","updated":"2017-06-05T01:44:17.000Z","comments":true,"path":"2016/04/09/Gradle/","link":"","permalink":"http://joytan1209.github.io/2016/04/09/Gradle/","excerpt":"","text":"简介Android Studio 使用 Gradle 构建工具，而 Gradle 继承了强大、灵活的 Ant 和 Maven 丰富的依赖管理，配置管理简单，脚本编写方便灵活，插件模块化。 Android Studio 使用 Gradle 构建工具，Eclipse 的 ADT 插件使用的是 Ant 构建工具。因为两个构建工具的区别，导致习惯了 Eclipse 开发环境的开发者刚开始比较难适应 Android Studio。如果要迁移到 Android Studio，建议最好了解下 Gradle 构建工具。Gradle 构建工具是任务驱动型的构建工具，并且可以通过各种 Plugin 插件扩展功能以适应各种构建任务。对应 Android 项目的 Gradle 插件就是 Android Gradle Plugin。 为什么使用Android Studio相比ADT的好处就不啰嗦了，好马配好鞍，Android Studio为什么采用Gradle作为构建工具呢？Gradle是一个优秀的构建系统和构建工具，可以通过插件来创建自定的义构建逻辑。Gradle的优点： 采用了Domain Specific Language(DSL 语言) 来描述和控制构建逻辑。 构建文件基于 Groovy，并且允许通过混合声明 DSL 元素和使用代码来控制 DSL 元素以控制自定义的构建逻辑。 支持 Maven 或者 Ivy 的依赖管理。 非常灵活。允许使用最好的实现，但是不会强制实现的方式。 插件可以提供自己的 DSL 和 API 以供构建文件使用。 良好的 API 工具供 IDE 集成。 Gradle构建系统的目标： 让重用代码和资源变得更加容易 让创建同一个APP的不同版本变得更加容易，无论是多个APP发布版本还是同一个发布不同的版本 让构建过程变得更加容易配置，扩展和定制 整合优秀IDE 项目的构建文件Gradle在Android Studio的项目中是如何使用的呢？一个Gradle项目的构建过程定义在了build.gradle的文件中，在项目的根目录下，如图： android项目 最简单的Android项目的build.gradle文件包含以下内容： 12345678910111213141516buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:0.11.1' &#125;&#125;apply plugin: 'android'android &#123; compileSdkVersion 19 buildToolsVersion \"19.0.0\"&#125; 简单分析下: 1buildscrip&#123;...&#125; 配置驱动构建过程的代码，在这个部分声明了使用Maven仓库，并且声明了一个maven文件的依赖路径。这个文件就是包含了0.11.1版本android gradle插件的库。 1apply plugin: 'android' 这里添加了android插件 1android&#123;...&#125; 这里配置android构建过程需要的参数 默认情况下，只需要配置目标编译SDK版本和编译工具版本，即compileSdkVersion和buildToolsVersion属性。 这个complieSdkVersion属性相当于旧构建系统中project.properites文件中的target属性。这个新的属性可以跟旧的target属性一样指定一个int或者String类型的值。 与上面基本的构建文件对应的是一个默认的文件夹结构。Gradle遵循约定优先于配置的概念，我们需要在可能的情况尽可能提供合理的默认配置参数。 基本的项目开始于两个名为“source sets”的组件，即main source code和test code。分别位于： src/main/ src/androidTest/里面每一个文件夹都有与之相应的源组件: AndroidManifest.xml res/ assets/ aidl/ rs/ jni/ 配置结构当默认的项目结构不适用的时候，你可能需要去配置它。根据Gradle文档，重新为Android项目sourceSets。例如： 123456789101112131415android &#123; sourceSets &#123; main &#123; manifest.srcFile 'AndroidManifest.xml' java.srcDirs = ['src'] resources.srcDirs = ['src'] aidl.srcDirs = ['src'] renderscript.srcDirs = ['src'] res.srcDirs = ['res'] assets.srcDirs = ['assets'] &#125; androidTest.setRoot('tests') &#125;&#125; 它使用了旧项目结构中的main源码，并且将androidTest sourceSet组件重新映射到tests文件夹。 构建任务添加一个插件到构建文件中将会自动创建一系列构建任务(build tasks)去执行（注：gradle属于任务驱动型构建工具，它的构建过程是基于Task的）。Java plugin和Android plugin都会创建以下task： assemble 这个task将会组合项目的所有输出。 check 这个task将会执行所有检查。 connectedCheck 这个task将会在一个指定的设备或者模拟器上执行检查，它们可以同时在所有连接的设备上执行。 deviceCheck 通过APIs连接远程设备来执行检查，这是在CL服务器上使用的。 build 这个task将会执行assemble和check两个task的所有工作 clean 这个task将会清空项目的输出。 实际上assemble，check，build这三个task不做任何事情。它们只是一个Task标志，用来告诉android plugin添加实际需要执行的task去完成这些工作。 这就允许你去调用相同的task，而不需要考虑当前是什么类型的项目，或者当前项目添加了什么plugin。 例如，添加了findbugs plugin将会创建一个新的task并且让check task依赖于这个新的task。当check task被调用的时候，这个新的task将会先被调用。 在命令行环境中，你可以执行以下命令来获取更多高级别的task： gradle tasks 查看所有task列表和它们之间的依赖关系可以执行以下命令： gradle tasks --all 注意：Gradle会自动监视一个task声明的所有输入和输出。两次执行build task并且期间项目没有任何改动，gradle将会使用UP-TO-DATE通知所有task。这意味着第二次build执行的时候不会请求任何task执行。这允许task之间互相依赖，而不会导致不需要的构建请求被执行。 一个Android项目至少拥有两个输出：debug APK（调试版APK)和release APK（发布版APK）。每一个输出都拥有自己的标识性task以便能够单独构建它们。 assemble assembleDebug assembleRelease它们都依赖于其它一些tasks以完成构建一个APK需要多个步骤。其中assemble task依赖于这两个task，所以执行assemble将会同时构建出两个APK。 check task也拥有自己的依赖： check lint connectedCheck connectedAndroidTest connectedUiAutomatorTest(目前还没有应用到） deviceCheck 这个test依赖于test创建时，其它实现测试扩展点的插件。 最后，只要task能够被安装（那些要求签名的task），android plugin就会为所有构建类型（debug，release，test）安装或者卸载。 基本的构建定制Android plugin提供了大量DSL用于直接从构建系统定制大部分事情。 Manifest 属性 通过SDL可以配置一下manifest选项： minSdkVersion targetSdkVersion versionName applicationId (有效的包名 – 更多详情请查阅ApplicationId 对比 PackageName) package Name for the test application Instrumentation test runner 例如： 1234567891011android &#123; compileSdkVersion 19 buildToolsVersion \"19.0.0\" defaultConfig &#123; versionCode 12 versionName \"2.0\" minSdkVersion 16 targetSdkVersion 16 &#125;&#125; 在android元素中的defaultConfig元素中定义所有配置。 构建类型默认情况下，Android Plugin会自动给项目设置同时构建应用程序的debug和release版本。 两个版本之间的不同主要围绕着能否在一个安全设备上调试，以及APK如何签名。 Debug版本采用使用通用的name/password键值对自动创建的数字证书进行签名，以防止构建过程中出现请求信息。Release版本在构建过程中没有签名，需要稍后再签名。 这些配置通过一个BuildType对象来配置。默认情况下，这两个实例都会被创建，分别是一个debug版本和一个release版本。 Android plugin允许像创建其他构建类型一样定制debug和release实例。这需要在buildTypes的DSL容器中配置： 12345678910111213android &#123; buildTypes &#123; debug &#123; applicationIdSuffix \".debug\" &#125; jnidebug.initWith(buildTypes.debug) jnidebug &#123; packageNameSuffix \".jnidebug\" jnidebugBuild true &#125; &#125;&#125; 以上代码片段实现了以下功能： 配置默认的debug构建类型 将debug版本的包名设置为.debug以便能够同时在一台设备上安装debug和release版本的apk。 创建了一个名为jnidebug的新构建类型，并且这个构建类型是debug构建类型的一个副本。 继续配置jnidebug构建类型，允许使用JNI组件，并且也添加了不一样的包名后缀。 创建一个新的构建类型就是简单的在buildType标签下添加一个新的元素，并且可以使用initWith()或者直接使用闭包来配置它。 签名配置对一个应用程序签名需要以下： 一个Keystory 一个keystory密码 一个key的别名 一个key的密码 存储类型 位置，键名，两个密码，还有存储类型一起形成了签名配置。 默认情况下，debug被配置成使用一个debug keystory。 debug keystory使用了默认的密码和默认key及默认的key密码。 debug keystory的位置在$HOME/.android/debug.keystroe，如果对应位置不存在这个文件将会自动创建一个。 debug Build Type(构建类型) 会自动使用debug SigningConfig (签名配置)。 可以创建其他配置或者自定义内建的默认配置。通过signingConfigs这个DSL容器来配置： 12345678910111213141516171819202122android &#123; signingConfigs &#123; debug &#123; storeFile file(\"debug.keystore\") &#125; myConfig &#123; storeFile file(\"other.keystore\") storePassword \"android\" keyAlias \"androiddebugkey\" keyPassword \"android\" &#125; &#125; buildTypes &#123; foo &#123; debuggable true jniDebugBuild true signingConfig signingConfigs.myConfig &#125; &#125;&#125; 以上代码片段修改debug keystory的路径到项目的根目录下。在这个例子中，这将自动影响其他使用到debug构建类型的构建类型。 运行 Proguard从Gradle Plugin for ProGuard version 4.10之后就开始支持ProGuard。ProGuard插件是自动添加进来的。如果Build Type的runProguard属性被设置为true，对应的task将会自动创建。 12345678910111213141516android &#123; buildTypes &#123; release &#123; runProguard true proguardFile getDefaultProguardFile('proguard-android.txt') &#125; &#125; productFlavors &#123; flavor1 &#123; &#125; flavor2 &#123; proguardFile 'some-other-rules.txt' &#125; &#125;&#125; 发布版本将会使用它的Build Type中声明的规则文件，product flavor（定制的产品版本）将会使用对应flavor中声明的规则文件。 这里有两个默认的规则文件： proguard-android.txt proguard-android-optimize.txt 这两个文件都在SDK的路径下。使用getDefaultProguardFile()可以获取这些文件的完整路径。它们除了是否要进行优化之外，其它都是相同的。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://joytan1209.github.io/tags/Android/"},{"name":"移动开发","slug":"移动开发","permalink":"http://joytan1209.github.io/tags/移动开发/"}]},{"title":"Android 6.0 动态权限管理","slug":"动态权限管理","date":"2016-04-08T06:16:09.000Z","updated":"2017-06-05T01:44:17.000Z","comments":true,"path":"2016/04/08/动态权限管理/","link":"","permalink":"http://joytan1209.github.io/2016/04/08/动态权限管理/","excerpt":"","text":"随着Android6.0的发布，更多的新特性被推出，极大的提升了用户体验，但同时也做了一些改变，对开发人员带来了一定的麻烦。 Android 6.0在我们原有的AndroidManifest.xml声明权限的基础上，又新增了运行时权限动态检测，以下权限都需要在运行时判断： 123456789身体传感器日历摄像头通讯录地理位置麦克风电话短信存储空间 运行时权限处理Android6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限，所以如果你以前的APP设置的targetSdkVersion低于23，在运行时也不会崩溃，但这也只是一个临时的救急策略，用户还是可以在设置中取消授予的权限。 虽然系统有默认的授权提示框，但我们人需要自己来配置页面。因为系统默认的授权提示框，有【不再提示】的选项，如果被选择，则再也无法触发授权提示了。只有使用我们自定义的授权提示页面，才可以引导用户修改授权。 权限权限有分为【危险权限】和【一般权限】，危险权限必须要授权才可以使用，一般权限则不需要，如：123456&lt;!--危险权限--&gt;&lt;uses-permission android:name=\"android.permission.READ_CALENDAR\"/&gt;&lt;uses-permission android:name=\"android.permission.WRITE_CALENDAR\"/&gt;&lt;!--一般权限--&gt;&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; 既然要实现自定义授权页面，那我需要写一个权限检查的工具类 1234567891011121314151617181920212223242526272829/** * 权限检查工具类 * * Created by tanchaoyin on 16/1/26. */public class PermissionsCheckerUtil &#123; private final Context mContext; public PermissionsCheckerUtil(Context context) &#123; mContext = context.getApplicationContext(); &#125; // 判断权限列表 public boolean checkPermissions(String... permissions) &#123; for (String permission : permissions) &#123; if (checkPermission(permission)) &#123; return true; &#125; &#125; return false; &#125; // 否缺少权限的判断 private boolean checkPermission(String permission) &#123; return ContextCompat.checkSelfPermission(mContext, permission) == PackageManager.PERMISSION_DENIED; &#125;&#125; 自定义授权页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/** * 权限获取页面 * * Created by tanchaoyin on 16/1/26. */public class PermissionsActivity extends BaseActivity &#123; public static final int PERMISSIONS_GRANTED = 0; // 权限授权 public static final int PERMISSIONS_DENIED = 1; // 权限拒绝 private static final int PERMISSION_REQUEST_CODE = 0; // 系统权限管理页面的参数 private static final String EXTRA_PERMISSIONS = \"com.tanchaoyin.permission.extra_permission\"; // 权限参数 private static final String PACKAGE_URL_SCHEME = \"package:\"; // 方案 private PermissionsChecker mChecker; // 权限检测器 private boolean isRequireCheckFlag; // 是否需要系统权限检测 public static void startActivityForResult(Activity activity, int requestCode, String... permissions) &#123; Intent intent = new Intent(activity, PermissionsActivity.class); intent.putExtra(EXTRA_PERMISSIONS, permissions); ActivityCompat.startActivityForResult(activity, intent, requestCode, null); &#125; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (getIntent() == null || !getIntent().hasExtra(EXTRA_PERMISSIONS)) &#123; throw new RuntimeException(\"呵呵，出错了哦。需要静态的startActivityForResult方法才可以启动哦！！！\"); &#125; setContentView(R.layout.activity_permissions); mChecker = new PermissionsChecker(this); isRequireCheckFlag = true; &#125; @Override protected void onResume() &#123; super.onResume(); if (isRequireCheckFlag) &#123; String[] permissions = getPermissions(); if (mChecker.lacksPermissions(permissions)) &#123; requestPermissions(permissions); // 请求权限 &#125; else &#123; allPermissionsGranted(); // 全部权限都已获取 &#125; &#125; else &#123; isRequireCheckFlag = true; &#125; &#125; // 返回传递的权限参数 private String[] getPermissions() &#123; return getIntent().getStringArrayExtra(EXTRA_PERMISSIONS); &#125; // 请求权限兼容低版本 private void requestPermissions(String... permissions) &#123; ActivityCompat.requestPermissions(this, permissions, PERMISSION_REQUEST_CODE); &#125; // 全部权限均已获取 private void allPermissionsGranted() &#123; setResult(PERMISSIONS_GRANTED); finish(); &#125; /** * 用户权限处理 * * @param requestCode * @param permissions * @param grantResults */ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; if (requestCode == PERMISSION_REQUEST_CODE &amp;&amp; checkAllPermissionsGranted(grantResults)) &#123; isRequireCheckFlag = true; allPermissionsGranted(); &#125; else &#123; isRequireCheckFlag = false; showMissingPermissionDialog(); &#125; &#125; // 判断是否有全部的权限 private boolean checkAllPermissionsGranted(@NonNull int[] grantResults) &#123; for (int grantResult : grantResults) &#123; if (grantResult == PackageManager.PERMISSION_DENIED) &#123; return false; &#125; &#125; return true; &#125; // 显示缺失权限提示 private void showMissingPermissionDialog() &#123; AlertDialog.Builder builder = new AlertDialog.Builder(PermissionsActivity.this); builder.setTitle(R.string.help); builder.setMessage(R.string.string_help_text); // 拒绝, 退出应用 builder.setNegativeButton(R.string.quit, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; setResult(PERMISSIONS_DENIED); finish(); &#125; &#125;); builder.setPositiveButton(R.string.settings, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; startAppSettings(); &#125; &#125;); builder.show(); &#125; // 启动应用的设置 private void startAppSettings() &#123; Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); intent.setData(Uri.parse(PACKAGE_URL_SCHEME + getPackageName())); startActivity(intent); &#125;&#125; 权限使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MainActivity extends BaseActivity &#123; private static final int REQUEST_CODE = 0; // 需要使用的所有权限 static final String[] PERMISSIONS = new String[]&#123; Manifest.permission.READ_CALENDAR, Manifest.permission.WRITE_CALENDAR, Manifest.permission.INTERNET &#125;; @Bind(R.id.toolbar) Toolbar toolbar; private PermissionsCheckerUtil permissionsCheckerUtil; // 权限检测器 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); setSupportActionBar(mTToolbar); permissionsCheckerUtil = new PermissionsCheckerUtil(this); &#125; @Override protected void onResume() &#123; super.onResume(); // 没有权限, 则进入权限配置页面 if (permissionsCheckerUtil.lacksPermissions(PERMISSIONS)) &#123; // 权限配置页面 startPermissionsActivity(); &#125; &#125; private void startPermissionsActivity() &#123; PermissionsActivity.startActivityForResult(this, REQUEST_CODE, PERMISSIONS); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); // 拒绝授权, 关闭页面, 没有主要权限的情况下无法运行 if (requestCode == REQUEST_CODE &amp;&amp; resultCode == PermissionsActivity.PERMISSIONS_DENIED) &#123; finish(); &#125; &#125;&#125; 一下这些权限，可以直接声明使用: 123456789101112131415161718192021222324252627282930313233343536373839android.permission.ACCESS_LOCATION_EXTRA_COMMANDSandroid.permission.ACCESS_NETWORK_STATEandroid.permission.ACCESS_NOTIFICATION_POLICYandroid.permission.ACCESS_WIFI_STATEandroid.permission.ACCESS_WIMAX_STATEandroid.permission.BLUETOOTHandroid.permission.BLUETOOTH_ADMINandroid.permission.BROADCAST_STICKYandroid.permission.CHANGE_NETWORK_STATEandroid.permission.CHANGE_WIFI_MULTICAST_STATEandroid.permission.CHANGE_WIFI_STATEandroid.permission.CHANGE_WIMAX_STATEandroid.permission.DISABLE_KEYGUARDandroid.permission.EXPAND_STATUS_BARandroid.permission.FLASHLIGHTandroid.permission.GET_ACCOUNTSandroid.permission.GET_PACKAGE_SIZEandroid.permission.INTERNETandroid.permission.KILL_BACKGROUND_PROCESSESandroid.permission.MODIFY_AUDIO_SETTINGSandroid.permission.NFCandroid.permission.READ_SYNC_SETTINGSandroid.permission.READ_SYNC_STATSandroid.permission.RECEIVE_BOOT_COMPLETEDandroid.permission.REORDER_TASKSandroid.permission.REQUEST_INSTALL_PACKAGESandroid.permission.SET_TIME_ZONEandroid.permission.SET_WALLPAPERandroid.permission.SET_WALLPAPER_HINTSandroid.permission.SUBSCRIBED_FEEDS_READandroid.permission.TRANSMIT_IRandroid.permission.USE_FINGERPRINTandroid.permission.VIBRATEandroid.permission.WAKE_LOCKandroid.permission.WRITE_SYNC_SETTINGScom.android.alarm.permission.SET_ALARMcom.android.launcher.permission.INSTALL_SHORTCUTcom.android.launcher.permission.UNINSTALL_SHORTCUT","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://joytan1209.github.io/tags/Android/"},{"name":"移动开发","slug":"移动开发","permalink":"http://joytan1209.github.io/tags/移动开发/"}]},{"title":"Android IPC机制","slug":"IPC机制","date":"2016-04-07T02:38:40.000Z","updated":"2017-06-05T01:44:17.000Z","comments":true,"path":"2016/04/07/IPC机制/","link":"","permalink":"http://joytan1209.github.io/2016/04/07/IPC机制/","excerpt":"","text":"Android IPC机制 在任何一个操作系统中都需要IPC机制的存在，例如：Linux中通过共享内存、命名通道等来实现进程间的通信。然而在Android系统中是什么来实现呢？答案是Binder。当然，不仅使用了Binder机制来实现了IPC,还使用了Socket实现不同终端之间的通信。 IPC介绍1、Serializable接口是Java中为对象提供标准的序列化和反序列化操作的接口，而Parcelable接口是Android提供的序列化方式的接口。 2、serialVersionUId是一串long型数字，主要是用来辅助序列化和反序列化的，原则上序列化后的数据中的serialVersionUId只有和当前类的serialVersionUId相同才能够正常地被反序列化。serialVersionUId的详细工作机制：序列化的时候系统会把当前类的serialVersionUId写入序列化的文件中，当反序列化的时候系统会去检测文件中的serialVersionUId，看它是否和当前类的serialVersionUId一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则说明版本不一致无法正常反序列化。一般来说，我们应该手动指定serialVersionUId的值： 1.静态成员变量属于类不属于对象，所以不参与序列化过程； 2.声明为transient的成员变量不参与序列化过程。 3.Parcelable接口内部包装了可序列化的数据，可以在Binder中自由传输，Parcelable主要用在内存序列化上，可以直接序列化的有Intent、Bundle、Bitmap以及List和Map等等 实现IPC的方式1、 Bundle：Bundle实现了Parcelable接口，Activity、Service和Receiver都支持在Intent中传递Bundle数据。 2、 Messenger：Messenger是一种轻量级的IPC方案，其底层是用AIDL实现的。Messenger是以串行的方式处理请求的，服务端只能一个个处理，不能并发执行。 3、 AIDL：第一步创建一个Service和一个AIDL接口，第二步创建一个类继承自AIDL接口中的Stub类并实现Stub类中的抽象方法，然后在Service的onBind方法中返回这个类的对象，再在客户端绑定服务端Service，建立连接后就可以访问远程服务端的方法。 1.AIDL支持的数据类型：基本数据类型、String和CharSequence、ArrayList、HashMap、Parcelable以及AIDL； 2.某些类即使和AIDL文件在同一个包中也要显式import进来； 3.AIDL中除了基本数据类，其他类型的参数都要标上方向：in、out或者inout； 4.AIDL接口中支持方法，不支持声明静态变量； 5.为了方便AIDL的开发，建议把所有和AIDL相关的类和文件全部放入同一个包中，这样做的好处是，当客户端是另一个应用的时候，可以直接把整个包复制到客户端工程中。 6.RemoteCallbackList是系统提供来删除跨进程Listener的接口。是一个泛型，可以管理任何的ALDL接口。 4、ContentProvider： 1.ContentProvider主要以表格的形式来组织数据，并且可以包含多个表； 2.ContentProvider还支持文件数据，比如图片、视频等，系统提供的MediaStore就是文件类型的ContentProvider； 3.ContentProvider对底层的数据存储方式没有任何要求，可以是SQLite、文件，甚至是内存中的一个对象都行； 4.要观察ContentProvider中的数据变化情况，可以通过ContentResolver的registerContentObserver方法来注册观察者； 5、Socket：Socket是网络通信中“套接字”的概念，分为流式套接字和用户数据包套接字两种，分别对应网络的传输控制层的TCP和UDP协议。 6、文件共享：这种方式简单，适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写的问题。 Binder连接池如果项目规模较大，创建过多的Service是不合理的，因为service是系统资源，过多的service会使得应用看起来很重，所以最好的做法是将所有的AIDL放在同一个Service中去管理。其工作机制是：每一个业务模块创建自己的AIDL接口并实现此接口，此时不同业务模块之间不能有耦合，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的Binder对象；对于服务端来说，只需要一个Service，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给它们，不同的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程Service去执行，从而避免了重复创建Service的过程。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://joytan1209.github.io/tags/Android/"},{"name":"移动开发","slug":"移动开发","permalink":"http://joytan1209.github.io/tags/移动开发/"}]}]}